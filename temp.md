[音乐]
在本节中，我们将了解您如何做出正确的决定
关于如何控制通过您的应用程序的数据流，
充分利用设备的资源。
为了从基于图块的渲染器中获得最佳性能，
最正确的事情之一是框架图。
这定义了框架的基本框架，
渲染通道，计算通道，
以及数据如何在它们之间流动。
为了从基于 tile 的硬件中获得最佳性能，
确保数据流
充分利用片上磁贴存储器，
最大限度地减少使用外部 DRAM 访问，
并确保顶点和片段处理
可以很好地并行化，没有任何调度气泡。
可以很好地并行化，没有任何调度气泡。
对于 Vulkan，确保
与显示子系统的最佳交互，
否则，您可能会发现 GPU
正在用于组合任务。
如果你弄错了这个骨架，
你丢掉了性能和内存带宽
以后不容易恢复。
渲染通道是基于图块渲染的主要构建块。
在片段着色期间，对于每个图块，图块缓冲区都被初始化
到渲染通道的起始状态，局部着色，
然后写回内存，
反映渲染过程结束时的状态。
这个设计的目的
是将高带宽访问保持在本地切片缓冲区内，
最大限度地减少 GPU 和外部 DRAM 之间的流量。
在渲染过程中，本地 tile-buffer 中保留的内容
永远不需要打主存
除非它在渲染通道之间保持不变。
例如，
多采样帧缓冲区可以作为 tile 回写的一部分来解析，
所以只有解析的数据会产生任何带宽开销。
原始多样本数据被简单地丢弃。
Vulkan API 在 API 中内置了显式渲染通道，
所以我们将从 Vulkan 开始，因为它更容易解释。
每个渲染过程都被声明为一个显式的 loadOp，
storeOp 和 resolveOp
对于每个附件。
loadOp 定义了在渲染通道开始时发生的事情。
此时“加载”
将从主内存中获取附件的现有内容。
对于 Mali，“CLEAR”或“DON'T_CARE”都将初始化图块
到当前应用清除颜色，
避免任何内存流量。
始终使用 loadOp 清除，
不是基于命令的清除，
为通行证开始，
因为 loadOp 初始化更有效。
storeOp 定义每个附件会发生什么
在渲染通道结束时。
此时的“STORE”会将内容写回内存，
而“DON'T_CARE”将简单地丢弃内容。
resolveOp 定义了如何处理多样本附件解析。
如果您使用多重采样，解决附件至关重要
在将它们写回内存之前在单个样本中。
存储所有这些样本是一个高带宽消耗，
所以总是在渲染过程中使用 resolveOp，
不是基于命令的解析。
对于这种情况，还记得设置
storeOp 在“DON'T_CARE”的多重采样附件上。
OpenGL ES 原则上遵循大致相同的指导，
但由于 API 没有明确的渲染通道概念
实现方式不同。
实现方式不同。
实现方式不同。
实现方式不同。
OpenGL ES 中的渲染通道完全是动态构建的
通过图形驱动程序，
基于应用程序进行的 API 调用。
一般来说，调用 glBindFramebuffer()
更改绘制目标，
或调用 eglSwapBuffers() 来结束一帧，
将当前排队的命令转换为渲染通道，
并开始一个新的。
其他 API 调用也可能导致类似的刷新行为。
最明显的是，
更改当前绘制目标的附件绑定，
调用 glFlush()、glFinish() 或 eglMakeCurrent()
都可以导致当前排队的命令
转换为渲染通道。
一些与调度相关的行为不太明显。
等待查询和围栏
在当前命令流中排队
将导致创建渲染通道
以便可以解决查询和围栏。
在创建渲染通道的情况下，
继续绘制到表面
将导致我们所说的增量渲染。
未来的绘图调用适用于已经在内存中的内容，
所以第二个渲染通道必须有效地执行 loadOp LOAD
用数据填充磁贴内存。
这是一项昂贵的手术，
因此旨在最大限度地减少渲染通道拆分。
对于 OpenGL ES，
对于 OpenGL ES，Mali 驱动程序使用 FrameBuffer 对象
作为一个容器来跟踪一些优化状态。
尽可能多地启用这些优化
我们建议在创建后将 FBO 状态视为不可变状态。
此外，如果您使用打包的 D24S8 纹理，
始终将两者都附加到帧缓冲区对象，
因为这最适合我们的 AFBC 帧缓冲压缩。
OpenGL ES 所需的行为与 Vulkan 相同。
没有明确的 loadOp，
但是渲染过程中的第一个命令，
在 glBindFramebuffer() 之后
在任何draw call之前，
应该是 Clear、ClearBuffer 或 Invalidate
如果您希望 Mali 使用快速路径切片初始化。
第一次平局后的清除将等同于 vkCmdClear，
这更慢且更昂贵。
如果渲染通道中附件的最后一个操作
在最后一次draw call之后，
在将绑定更改为新的帧缓冲区之前，
是无效的，那么数据将被丢弃
并且根本没有写回内存。
对于多重采样附件，
确保您使用 EXT_multisampled_render_to_texture 扩展
受益于内联样本解析。
避免使用 glBlitFramebuffer() 进行多重采样解析，
因为这意味着多重采样数据必须通过 DRAM 往返。
最强大的技术之一
用于诊断渲染通道效率低下
是绘制框架图，
显示渲染通道和它们之间的数据流。
在这个图中，大的灰色框是渲染通道，
白色的小盒子是附件，
线条显示数据流。
实线表示用作附件，
而虚线表示作为纹理的消耗。
绘制框架图的基本技术相对简单。
将每个渲染通道视为一个盒子，
每个附件都有输入和输出插座。
每个输入套接字必须被清除或失效
为了避免从内存中加载，
并且每个输出套接字都必须失效
以避免存储到内存中。
在绘制这些图表时，
记得在 API 中包含所有类似渲染过程的结构，
例如计算调度、副本和 blit。
他们都使用相同的 GPU
他们的数据也必须流经DRAM，
所以值得让它们进入可视化。
在这里，我们有一个简单的框架图示例，
显示五个渲染通道之间的数据流。
图的主要渲染部分使用了阴影贴图，
然后两次照明，
一种用于不透明对象，另一种用于放置在顶部的透明对象。
顶部应用了运动模糊，
使用速度图来模糊主渲染的结果
在最后的后处理步骤中。
此步骤中突出显示的附件没有输入，
因此，应该清除或无效
作为传递中的第一个操作。
这避免了来自 DRAM 的不必要的回读
在每次传球开始时。
此步骤中突出显示的附件没有下游消费者，
所以应该作为pass中的最后一个操作无效。
这避免了在每次传递结束时对 DRAM 进行不必要的写入。
在此示例中，我们可以看到直接馈通，
读取一次传递的输出附件的情况
作为稍后传递的输入附件，
没有任何干预用作纹理。
这些可以合并到一个渲染通道中，
避免中间分裂。
在这个例子中，我们可以看到一个真实框架图的提取。
我们在这里看到的第一个问题
是一个实际上没有消费者的渲染通道，
整个过程可以优化掉
由应用程序渲染引擎。
我们可以看到的第二个问题，
是没有消费者的深度依恋。
我们可以看到的第三个问题是部分馈通，
我们可以看到渲染通道 3 直接消耗
渲染通道 2 的许多输出
作为输入附件。
这不是一个完整的馈线，
 渲染通道 2 生成的两个颜色附件
渲染通道 3 不使用，
但仍然可以将它们合并为一个通道
并使用 glDrawBuffers 跳过对未使用附件的写入
在第二次“通过”期间。
最后我们有另外三个渲染通道的序列
使用馈通附件。
这些可以合并到一个渲染通道中。
这里的每一行代表读取内存中的 1080p 图像，
所以优化这些可以节省大量的带宽。
AFBC 是 Arm 专有的无损帧缓冲压缩，
这通常会提供 30% 到 50% 的压缩率，
取决于图像。
像大多数无损帧缓冲压缩方案一样，
它对应用程序是透明的。
如果可能，驱动程序会自动启用它。
在当前的硬件上，每像素格式仅压缩 32 位，
在 Bifrost 系列硬件上，
根本没有浮点压缩。
未解析的 MSAA 数据也没有压缩，
因此，请务必在磁贴回写上解析为单个样本。
此外，AFBC 不支持在着色器中加载或存储图像。
这些将执行未压缩的读取和写入，
如果图像被压缩，则需要在第一次使用时进行解压缩。
对于 Vulkan，AFBC 的使用是静态确定的
基于创建图像视图时使用的图像标志。
要使用 AFBC，
图像必须使用 IMAGE_TILING_OPTIMAL 内存布局，
并且不得使用 IMAGE_USAGE_STORAGE，
IMAGE_USAGE_TRANSIENT，
或 IMAGE_CREATE_ALIAS。
颜色数据的平铺内存需要能够存储
同时所有颜色附件，
在考虑附件数量时，
样本数，
以及它们的颜色格式。
在现代 Mali 上使用超过 256 位/像素
将导致瓷砖尺寸下降，
这将产生效率开销。
这在实践中很少出现问题，
但要小心使用带有 MRT 附件的多重采样。
计算着色器提供了一种使用着色器核心的方法
作为通用并行处理引擎
但是，请注意，这会导致功能丧失
与固定功能管道相比。
在有一些的地方使用计算
这样做的重要算法优化，
例如摊销工作的能力
每次计算输出多个像素。
用计算着色器简单地替换片段着色器
通常会导致性能的净损失，
作为专用加速器，
例如变化的插值器和帧缓冲压缩
无法访问。
如前所述，使用图像的效率可能低于纹理。
仅使用 imageLoad/Store
适用于您需要能够写入图像数据的情况。
对于只读访问，请使用纹理操作。
基于图块的渲染运行一个很深的管道，
来自不同渲染通道的重叠顶点和片段处理
保持 GPU 硬件忙碌。
维护这条管道，
具有良好的重叠和最小的调度气泡，
对渲染效率至关重要。
对于 OpenGL ES，大部分依赖管理
由司机处理，
所以要注意的主要事情是 API 调用
这可能会导致整个管道排水，
驱动程序或硬件队列之一必须阻塞的位置
并等待系统的另一部分赶上。
glFinish()、glMemoryBarrier() 和同步 glReadPixels()
都是可以使管道停滞的事情的好例子。
要记住的另一件事是工作需要很长时间来处理，
虽然这条管道可能有延迟但得到工作
等于一帧渲染，
所以不要尝试触摸 CPU 上的资源
在命令中使用它们后为时过早。
旨在等待至少一帧，最好是两帧，
在等待围栏或阅读查询结果之前。
在 Vulkan 中，管理 GPU 命令之间的执行依赖关系
是应用程序的责任。
这些依赖关系需要足够严格以确保正确渲染，
但不是那么严格，它们会阻止并行性。
将依赖项 srcStage 设置为尽可能早地在管道中，
并将依赖项 dstStage 设置为尽可能晚。
 如果您正在努力让两次传球重叠，
考虑发布一个完全不相关的阶段
在两个相关阶段之间，
这将为第一阶段的完成留出更多时间。
当心简单选项的诱惑。
将 srcStage 设置为 BOTTOM OF PIPE，将 dstStage 设置为 PIPE 的 TOP 是安全的，
但它序列化了所有的 GPU 执行
并防止通道之间的所有重叠。
计算着色器在与几何处理相同的硬件队列中执行，
所以要小心计算着色器导致调度中的气泡。
如果在片段着色器中使用计算着色器的输出，
旨在在片段着色器之前运行一些非依赖的工作，
让 GPU 内核保持忙碌。
离散 GPU 通常需要传输操作
在系统 RAM 和图形 RAM 之间迁移资源。
对于移动平台，基于统一内存，
它们的需要较少。
因此，尽可能避免它们，
因为它们浪费带宽。
对于 Vulkan，应用程序设置交换链行为。
双缓冲，使用交换链中的两个图像，
为游戏提供最低的输入延迟
但由于大多数移动设备在启用 Vsync 的情况下运行，
如果应用程序缺少 Vsync 截止日期，它还可以限制帧速率。
观察到的帧速率将捕捉到
面板刷新率的整数除法，
60、30、20、15 等等。
为了获得最佳吞吐量，但延迟更高，
在交换链中运行三个图像。
这称为三重缓冲，
并允许 GPU 继续处理
在等待显示器扫描出图像时。
双缓冲的一项挑战
是你不会观察到任何改善
直到您的 FPS 超过下一个阈值，
因此，优化似乎无助于观察到的帧速率。
即使您打算使用双缓冲发送标题，
 减少输入延迟，
我们建议在分析工作期间使用三重缓冲
让每个人都能看到正在实现的真实帧速率。
移动设备可以旋转，
应用程序视图通常旋转
匹配设备的逻辑方向，
而不是面板的物理方向。
这对于显示控制器的效率至关重要
内存中帧缓冲区的方向
匹配面板的物理扫描输出方向。
以错误的方向传入缓冲区
可能会产生额外的后台处理，
使用专用的合成引擎，
或 GPU 本身，
这将消耗您游戏的功率预算。
对于 OpenGL ES，这一切都是由驱动程序透明协商的，
但是，对于应用程序开发人员 Vulkan
必须处理面板旋转事件。
每一帧，使用交换链中的 preTransform 提示
并确保您的交换链输出图像与面板方向匹配。
并确保您的交换链输出图像与面板方向匹配。
在接下来的视频中，
我们将介绍一些引擎和 API 最佳实践，
帮助您避免常见问题。
[音乐]
