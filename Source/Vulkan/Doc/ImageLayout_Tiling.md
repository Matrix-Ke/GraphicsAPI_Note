#! https://zhuanlan.zhihu.com/p/548753437
# Vulkan图像布局和排列 Image Layout和Tiling区别

理解layout 和 tiling的区别

**tiling**

Tiling是关于纹理像素的布局方式， tiling 分为 linear 和 optimal，linear 即为 row-major，一行一行顺序记录的图片格式，也是一般情况下读进应用程序的图像的排列方法。这种方法虽然比较简单，但可以发现，一行中的两个相邻像素地址挨在一起，但一列中的两个相邻的像素地址则差了一整行！这对于GPU在做 filtering 的时候是灾难性的远，很多使用 `texture` 进行采样的临近像素（PCF、高斯滤波）值都不在纹理缓冲（texture cache）中。所以我们要想个方法让在空间中相邻的像素点的内存位置也尽可能挨在一起，这就诞生了 optimal tiling。《VulkanToturial》教程中staging buffer 结合上 `vkCmdCopyBufferToImage `来隐式的转换 tiling。staging buffer 中存储的图像永远是 Linear 的，因为图像在硬盘存储时使用线性布局，同时我们不能知道驱动程序用何种方法来实现 optimal tiling 所以也无法按照 optimal tiling 保存。同时需要注意，optimal tiling 的图像无法使用 host 可见内存形式，原因同上。

**layout**

layout是一种GPU对纹理的一种**无损压缩**处理(Delta Color Compression、Depth Block 等），具体可以了解下文翻译。从而节省带宽。所以不要图省事儿就用 `GENERAL`，使用 validation layer 来验证是否将 layout 设定正确吧。


## 参考资料：
关于 DCC，可以在 https://gpuopen.com/dcc-overview/ 中了解到。

翻译：

带宽始终是 GPU 上的稀缺资源。一方面，随着 HBM 等更快的内存标准的引入，硬件取得了巨大的进步，但另一方面，游戏正在以更高的分辨率渲染，更大的缓冲区和更多的数据，占用了大量的带宽。大部分带宽用于读取和写入渲染目标。没有被利用的是渲染目标倾向于存储缓慢变化的数据这一事实。例如，天空是蓝色的，几乎没有变化，但 GPU 会独立处理每个像素，就好像它们包含所有唯一的、不相关的值一样。 

最近，随着 Delta 颜色压缩（简称 DCC）的引入，这种情况发生了变化。这是一种特定于域的压缩，它试图利用这种数据一致性来减少所需的带宽。它是无损的，在许多方面类似于典型的压缩器，但适用于 3D 渲染。关键思想是处理整个块而不是单个像素。在一个块中，只有一个值以全精度存储，其余的值存储为增量——因此得名。如果颜色相似，则增量值可以使用相对于输入少得多的位。在基于GCN 1.2的离散 GPU 和 APU 上启用 DCC 或更晚。实际的硬件实现比我刚才描述的要好得多。例如，它根据访问模式（和数据本身）调整其块大小，以优化潜在的随机访问。

新的压缩器位于颜色块内部，它允许图形压缩颜色渲染目标，类似于深度块压缩深度和模板目标的方式。这意味着不需要特殊设置：如果目标表面被压缩，则渲染只需通过压缩器。否则，管道不受影响。

压缩只是故事的一半，因为数据的读取频率通常远高于写入频率。为了在那里获得节省带宽的好处，着色器核心已被赋予读取新压缩颜色以及所有现有压缩表面的能力。这允许在渲染到纹理的场景中完全跳过解压缩操作——也就是说，从渲染目标到纹理的转换屏障实际上是​​无操作的，不会触发代价高昂的解压缩。

该做什么和不该做什么
虽然 DCC 是一个“透明”功能，因为它不需要开发人员进行特定设置，但要充分利用它，仍然需要注意一些注意事项。

1) 清零到 0.0s 和 1.0s
清除为 0.0s 和 1.0s 等常用值将比任意值快得多并节省更多带宽。

颜色更容易处理不透明或透明的黑色或白色，因此使用 {1.0, 0.0, 0.0, 0.0}, {0.0, 1.0, 1.0, 1.0} 或全部 0.0s 或 1.0s 来获得 ARGB 表面的清晰颜色。1.0s 和 0.0s 的任意组合最适合两种通道格式。
深度为 0.0 或 1.0
0x00 用于模板
仅在您知道需要时才尝试清除；如果你知道你肯定会写到所有的表面，通常没有必要。
2) 不要将渲染目标标记为着色器可读，除非你真的需要它们
着色器可读目标的压缩不如已知着色器不会读取它们时那么好。如前所述，着色器核心已被扩展，可让它们直接访问压缩数据，但还有其他压缩选项，只有在禁止从着色器核心读取访问时才可用。MSAA 深度目标最容易被标记为“着色器资源”，如果它们不需要，因为它们压缩得非常好。

3) 尝试使用 32 位浮点深度缓冲区格式 (D32F) 而不是 16 位 (D16) 以获得更好的性能
D32Fs 在用作着色器资源时实际上可能会比 D16s 压缩得更小，而在不兼容着色器时以完全相同的方式进行压缩。它们仅在解压缩时分配大小和带宽不同，这通常不会太频繁（但可能会在将具有许多微三角形的密集网格渲染到小的屏幕空间区域时发生）。D32F 还允许您使用 反向 Z 来增加精度，因此几乎可以免费使用。请记住，在 GCN 上，没有真正的 24 位深度目标。在引擎盖下，这些被处理为 32 位，只是丢弃了 8 位精度——因此从 D24 切换到 D32 目标没有成本。

4) 一般尝试 mipmapping 或预过滤，而不是稀疏读取图像
稀疏读取一开始是不好的，因为它们会破坏缓存。压缩会使稀疏读取变得更糟，因为现在它不是颠簸一个缓存，而是颠簸两个。有没有发现飞行中的波数越少或每波有效线程越少实际上会提高性能？一个可能的原因是缓存正在被破坏。特别是我们有时会观察到阴影贴图过滤的稀疏读取在启用压缩的情况下会变得非常糟糕。这尤其发生在利基“超”图形质量模式上，其中设置往往被提高到 11。如果阴影看起来嘈杂和混叠，那么缓存就会被破坏！预过滤或选择较低的分辨率会看起来更好并且运行得更快。

5) 尽可能写所有颜色通道，即使有些是多余的
部分写入需要特别小心。在未压缩数据的情况下，可以简单地屏蔽写入。对于压缩数据，这不起作用，因此必须首先读取、解压缩、更新数据，然后再写回以保留未触及的通道。为了有效地使用压缩，如果混合不需要底层数据，最好完全覆盖底层数据，尽可能同时写入所有通道。

6）组织G-Buffer数据以最大化压缩
如果将任意位打包字段放入 G 缓冲区，则将高度相关的位放入每个通道的最高有效位 (MSB) 中，并将噪声数据放入每个通道的最低有效位 (LSB) 中。这将更好地压缩，因为它对典型数据模式的响应类似。

什么时候仍然会发生解压缩？
RDNA/RDNA 2 更新：要查看驱动程序和 ASIC 组合实际发生的情况，请务必使用我们的Radeon GPU Profiler (RGP) 工具进行检查。
您可以在此处找到 RGP 中的 DCC 信息。
 即使您已遵循上述所有规则，DCC 有时也可能会被禁用，因为并非 GPU 的所有部分都可以读取和写入压缩数据。在这些情况下，屏障将导致减压。了解这些情况何时发生很重要：

同时写入和读取压缩目标时。
这在元数据和数据之间不一致，因此会发生损坏。
驱动程序必须谨慎行事——即使可能 同时访问它也会解压缩，因此请确保在显式 API（Direct3D® 12、Vulkan™）中正确设置使用标志，并且在不希望的情况下将表面未绑定和/或写入屏蔽要写。
当着色器可以作为无序访问视图 (UAV) 写入资源时
通过着色器将纹理标记为可写为 UAV 目前完全不允许压缩。
一些驱动程序可能仍然允许快速清除，然后在着色器 UAV 写入绑定上解压缩，直到下一次完全清除。
在使用复制引擎之前。
通常一旦标记为复制源或目标，我们首先解压缩，因为我们不知道它的去向。
原始副本可以在相同类型和大小的表面之间完成……如果驾驶员知道这将发生。


**参考资料**

[vulkan学习] (https://gavinkg.github.io/ILearnVulkanFromScratch-CN/)